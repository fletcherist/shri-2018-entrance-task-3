# Яндекс.Переговорки

В **«Переговорках»** следующие зависимости:

* `preact` — просто попробовал
* `flow` — использую статическую типизацию в каждом проекте, чтобы меньше писать тестов.
* `parcel` — новая штука, тоже попробовал
* `fela` (css in js), плохой выбор — совершенно неуместно
* `redux` — must have
* `redux-saga` — потому что это лучшая реализация для работы асинхронными событиями в `redux`
* `lokka` — graphql client
* `preact-redux`
* `preact-router`
* `ramda` — фп
* `css modules`


> Стоит отметить, что заиспользовать новые хипстерские штуки было довольно опрометчивой идеей: в `parcel` на тот момент не работал `import .css`, а `preact-fela` вообще не собирался, так что пришлось закинуть им `PR` с фиксом. В этот раз я решил не использовать `boilerplate`, а собирал архитектуру руками.


<img height=300 src='https://i.imgur.com/3AJbDd9.gif'/>


> а) Может быть, можно перенести встречу из неё в другую переговорку (например, меньших размеров). б) Если переговорки заняты не на весь период времени, стоит попробовать освободить одну из них, перенеся встречи в другие подходящие переговорки. Например, есть встреча с 11:00 до 12:00 и есть две подходящие переговорки А (занята с 11:00 до 11:30) и B (занята c 11:30 до 12:00).

Эти два замечания кажутся мне в некоторой степени неточными — с одной стороны, отжимать уже забронированные переговорки не совсем честно, а с другой — мне кажется, здесь перепутана причина со следствием, ведь причина неоптимального заполнения комнат — есть следствие плохой рекомендательной системы. Поэтому, вместо этого предлагаю сделать подбор комнаты таким образом, чтобы в неё с одной стороны помещались люди (`usersAmount > roomCapacity`), а с другой — чтобы первыми показывать комнаты наименьших размеров.


Кажется, что так можно решить проблему перенаселения.


Когда человек вводит начало и конец бронирования, начинаем фильтровать комнаты, учитывая их занятость в данный период времени.

На десктопах рабочий день начинается с девяти. На мобильных — с восьми.

# Компоненты
  Я разберу самые интересные.

### event-tooltip
+ [component](https://github.com/fletcherist/shri-2018-entrance-task-3/blob/master/src/components/event-tooltip.js)
+ [container](https://github.com/fletcherist/shri-2018-entrance-task-3/blob/master/src/containers/event-tooltip.js)
+ [управление поведением](https://github.com/fletcherist/shri-2018-entrance-task-3/blob/master/src/sagas/modalsSaga.js#L12)

Наверное, самый сложный элемент интерфейса. Я делал такой первый раз.

#### Как

На каждое событие не свой отдельный `event-tooltip`, а он один на всё приложение. При клике на событие вычисляет абсолютные координаты ивента на сетке, и вычисляет такое положение тултипа, чтобы он всегда оказывался посередине ивента (см. гифку).

#### Почему

Использование данного подхода было оправдано тем, что вариант, где много на каждое событие своя модалка некорректно отображался на пересечении со списком комнат (транзитивно: `z-index` `списка` **>** `диаграммы`, поэтому всё, что находится в диаграмме, будет находиться **за списком**, сколько бы девяток мы там не писали)


<img height=300 src='https://i.imgur.com/7RBHJGn.gif'/>


### date-swticher
+ [component](https://github.com/fletcherist/shri-2018-entrance-task-3/blob/master/src/components/date-switcher.js)

+ [формат даты](https://github.com/fletcherist/shri-2018-entrance-task-3/blob/master/src/utils/formatTimeIntoDateSwitcher.js)

#### Почему

Я намеренно использовал здесь нативный календарь, чтобы показать, что мы должны пользоваться нативными браузерными средствами, потому что они ничуть не хуже кастомных, а даже лучше, отзывчивее и доступнее.


<img height=300 src='https://i.imgur.com/tOeZsRo.gif'/>






# Благодарность

Спасибо за по-настоящему сложное и интересное задание. Я с одной стороны был удивлён, а с другой — обрадовался, когда мне не удалось сделать его за выходные. 

